[TOC]

### 面向对象

---

#### 特点

> 1. 将复杂的事情简单化；
> 2. 面向对象将以前的过程中的执行者，变成了指挥者；
> 3. 面向对象这种思想时符合现代人们思考的一种思想；

>  过程和对象在我们的程序中如何体现的呢？<font color='#FF3399'>过程</font>其实就是函数；<font color='#FF3399'>对象</font>是将函数等一些内容进行了封装；

#### 成员

> 在类中定义其实都称之为成员。成员有两种：
>
> - **成员变量：** 其实对应的是事物的属性；
> - **成员函数：** 其实对应的是事物的行为；
>
> 所以，定义类，就是在定义成员变量和成员函数。但是在定义之前，必须先要对事物进行属性和行为的分析，才可以用代码来体现。

#### 匿名对象使用场景

> 1. 当对方法值进行一次调用时，可以使用匿名对象；
>
> 2. 当对象对成员进行多次调用时，不能使用匿名对象。必须给对象起名字。
>
> 3. ``` java
>   // 普通对象
>   Car car = new Car();
>   car.run();
>   // 匿名对象
>   new Car().run();
>   ```

#### 修饰符及作用范围

> | 权限修饰符 | 同一个类 | 同一个包 | 子类 | 外部包 |
> | :--------: | :------: | :------: | :--: | :----: |
> |  private   |    √     |          |      |        |
> |    缺省    |    √     |    √     |      |        |
> | protected  |    √     |    √     |  √   |        |
> |   public   |    √     |    √     |  √   |   √    |

> **private：** 其他类不能直接创建对象访问，所以只有通过本类对外提供具体的访问方式来完成对私有的访问；

> **总结：** 属性是用于存储数据的，直接被访问，容易出现安全隐患，所以，属性常常被私有化，并对外提供公共的访问方法。

#### 成员变量和局部变量的区别

> 1. 成员变量直接定义在类中，局部变量定义在方法中、参数中、语句中；
> 2. 成员变量在这个类中有效，局部变量只在自己所属的大括号内有效，大括号结束，局部变量失去作用域；
> 3. 成员变量存放在堆内存中，岁对象的产生而产生，消失而消失；局部变量存在栈内存中，随着所属区域的运行而存在，结束而释放；

#### 构造函数

> 用于给对象进行初始化，是给与之对应的对象进行初始化，它具有针对性，函数中的一种。
>
> **格式：**
>
> ```java
> // 无参
> 修饰符 类名() {}
> // 有参
> 修饰符 类名(参数类型 参数1, ......) {
>     ......
> }
> ```
>
> **特点：**
>
> > 1. 该函数名称与所在的类名称相同；
> > 2. 不需要定义返回值类型；
> > 3. 该函数没有具体的返回值类型；
>
> **注意事项：** 一个类在定义时，如果没有定义构造函数，那么该类会自动生成一个空参的构造函数。如果类中自定义了构造函数，那么默认的构造函数就没有了。一个类中可以有多个构造函数，通过参数列表来区分，它们的存在是以<font color='#FF3399'>重载</font>来体现的。
>
> **构造函数与一般函数的区别：**
>
> > 1. 定义格式不同；
> > 2. 构造函数在对象创建时会被调用，用于初始化，而且初始化动作只执行一次；一般函数，是对象创建后，需要调用时才执行，可以调用多次。

#### 构造代码块与静态代码块

> **构造代码块：**
>
> > 1. 构造代码块的作用是给对象进行初始化；
> > 2. 对象一建立就运行构造代码块了，而且优先于构造函数执行；
> > 3. 构造代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化；
>
> **静态代码块：**
>
> > 1. 它随着类的加载而执行，只执行一次，并优于主函数；
> > 2. 静态代码块其实是给类初始化，而构造函数是给对象初始化；
> > 3. 静态代码块中的变量时局部变量，与普通函数中的局部变量性质没有差别；
> > 4. 一个类中可以有多个静态代码块；

#### this关键字

> 代表对象，就是所在函数所属对象的引用。
>
> this还可用于构造函数间的调用。
>
> **调用格式：**
>
> > 1. this后面跟上 . 调用的是成员属性和成员方法；
> > 2. this后面跟上()调用的是本类中对应参数的构造函数；
>
> <font color='#FF3399'>**注意：**</font>用this调用构造函数时，必须定义在构造函数的第一行，因为构造函数使用与初始化的，所以初始化动作一定要执行。否则编译失败。

#### static关键字

> 是一个修饰符，用于修饰成员（成员变量和成员方法）；
>
> **特点：**
>
> > 1. **想要实现对象中的共性数据的对象共享，可以将这个数据进行静态修饰。**
> > 2. **被静态修饰的成员，可以直接被类名所调用。** 也就是说，静态的成员多了一种调用方式。**类名.静态方式**。
> > 3. **静态随着类的加载而加载，而且优先于对象存在。**
>
> **弊端：**
>
> > 1. 有些数据是对象特有的数据，是不可以被静态修饰的。因为那样的话，特有数据会变成对象的共享数据。这样对事物的描述就出了问题。所以，在定义静态时，必须要明确，这个数据是否是被对象所共享的。
> > 2. **静态方法只能访问静态成员，不可以访问非静态成员。** 因为静态方法加载时，优先于对象存在，所以没有办法访问对象中的成员。
> > 3. **静态方法中不能使用this，super关键字。** 因为this代表对象，而静态在时，有可能没有对象，所以this无法使用。
> > 4. 主函数是静态的。
>
> **成员变量与静态变量的区别：**
>
> > 1. 成员变量所属于对象，所以也称为实例变量；静态变量所属于类，所以也称为类变量；
> > 2. 成员变量存在于堆内存中；静态变量存在于方法区中；
> > 3. 成员变量随着对象创建而存在，随着对象被回收而消失；静态变量随着类的加载而存在，随着类的消失而消失；
> > 4. 成员变量只能被对象所调用；静态变量可以被对象调用，也可以被类名调用；

#### final关键字

> 1. <font color='#0066CC'>**这个关键字是一个修饰符，可以修饰类，方法，变量。**</font>
> 2. <font color='#0066CC'>**被final修饰的类是一个最终类，不可以被继承。**</font>
> 3. <font color='#0066CC'>**被final修饰的方法是一个最终方法，不可以被覆盖。**</font>
> 4. <font color='#0066CC'>**被final修饰的变量是一个常量，只能赋值一次。**</font>

> **命名规范：**所有字母大写，如果有多个字母组成，中间用"_"连接。

#### 抽象类：abstract

> 只做声明，不做实现。格式为：
>
> ``` java
> public sbstract Car {
>     abstract void run();
> }
> ```
>
> 如果一个类中包含抽象方法，则该类为抽象类，但并不意味着抽象类只能有抽象方法，它和普通类一样，同样可以拥有成员变量和成员方法。
>
> **抽象类的特点**
>
> > 1. <font color='#0066CC'>**抽象方法只能定义在抽象类中，抽象类和抽象方法必须由abstract关键字修饰（可以描述类和方法，不可以描述变量）。**</font>
> > 2. <font color='#0066CC'>**抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。**</font>
> > 3. <font color='#0066CC'>**抽象方法只定义方法声明，并不定义方法实现。**</font>
> > 4. <font color='#0066CC'>**抽象类不可以被创建对象(实例化)。**</font>
> > 5. <font color='#0066CC'>**只有通过子类继承抽象类并覆盖了抽象类中的所有抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。**</font>
>
> **抽象类的细节**
>
> > 1. **抽象类中是否有构造函数？** 有，用于给子类对象进行初始化。
> > 2. **抽象类中是否可以定义非抽象方法？** 可以。其实，抽象类和一般类没有太大的区别，都是在描述事物，只不过抽象类在描述事物时，有些功能不具体。所以抽象类和一般类在定义上，都是需要定义属性和行为的。只不过，比一般类多了一个抽象函数。而且比一般类少了一个创建对象的部分。
> > 3. **抽象关键字abstract和哪些不可以共存？** final , private , static
> > 4. **抽象类中可不可以不定义抽象方法？** 可以。抽象方法目的仅仅为了不让该类创建对象。

#### 接口类：interface

> 接口泛指供别人调用的方法或者函数。格式为：
>
> ``` java
> public interface InterfaceName {
>     void run();
> }
> ```
>
> 接口中可以含有变脸和方法。但要注意，接口中的变量会被隐式地指定为 public static final 变量，方法会被隐式的指定为 public abstract 方法，并且接口中所有方法不能有具体实现，也就是说，接口中的方法必须都是抽象方法。
>
> 在Java 1.8中出现了新特性，就是接口中可以定义默认方法。格式为：
>
> ``` java
> public interface Car {
>     default void run() {
>         ......
>     }
> }
> ```
>
>

### 封装

> 面向对象特征之一，是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。
>
> **好处：** 将变化隔离；便于使用；提高重用性、安全性；
>

### 继承

> 面向对象特征之一；
>
> **好处：**
>
> > 1. 提高代码复用性；
> > 2. 让类与类之间产生了关系；
>
> **父类的由来：** 其实是有多个类不断的向上抽取共性内容而来。
>
> **单继承原因：** Java中对于继承，只支持单继承。因为当一个类继承两个父类时，两个父类中有相同的功能，那么子类调用该功能时，运行哪一个呢？所以只支持单继承。但是Java支持多重继承。A继承B，B继承C，C继承D。
>
> **父子类出现后，类中的成员有哪些变化？**
>
> > 1. **成员变量**
> >
> >    > 当父子类中出现一样的属性时，子类类型的对象，调用该属性，值时子类的属性值；
> >    >
> >    > 如果想要调用父类的属性值，需要使用关键字<font color='#ff3399'>super</font>；
> >    >
> >    > this：代表的是本类类型的对象引用；
> >    >
> >    > super：代表的是子类所属的父类的内存空间引用；
> >    >
> >    > **注意：** 父子类中一般是不会出现同名成员变量的，因为只要父类定义了，子类就不用子定义了，直接继承过来就可以了。
> >
> > 2. **成员函数**
> >
> >    > 当子父类中出现了一模一样的方法时，建立子类对象会运行子类中的方法。好像父类中的方法被覆盖掉一样。所以这种情况，是函数的另一个特性：**覆盖(复写，重写)**。
> >    >
> >    > **什么时候使用覆盖呢？当一个类的功能内容需要修改时，可以通过覆盖来实现。**
> >
> > 3. **构造函数**
> >
> >    > <font color='#FF6666'>发现子类构造函数运行时，先运行了父类的构造函数</font>。为什么呢？因为子类的**所有构造函数中的第一行**，其实都有一条隐身的语句super();
> >    >
> >    > super()：表示调用父类中无参的构造函数。为什么子类对象初始化时，需要调用父类中的函数呢？因为子类继承父类，会继承到父类中的数据，所以必须要看父类是如何对自己的数据进行初始化的。所以子类在进行对象初始化时，先调用父类的构造函数，这就是**子类的实例化过程**。
> >
> >    <font color='#FF0033'>**注意：**</font>
> >
> >    > 1. <font color='#0066CC'>**子类中所有的构造函数都会默认访问父类中的空参数的构造函数，因为每一个子类构造内第一行都有默认的语句super();**</font>
> >    > 2. <font color='#0066CC'>**如果父类中没有空参数的构造函数，那么子类的构造函数内，必须通过super语句指定要访问的父类中的构造函数；**</font>
> >    > 3. <font color='#0066CC'>**如果子类构造函数中用this来指定调用子类自己的构造函数，那么被调用的构造函数也一样会访问父类中的构造函数。**</font>
> >
> >    **问题：**
> >
> >    > 1. **super()和this()是否可以同时出现的构造函数中？**
> >    >
> >    >    > 两个语句只能有一个定义在第一行，所以只能出现其中一个。
> >    >
> >    > 2. **super()或者this()为什么一定要定义在第一行？**
> >    >
> >    >    > 因为super()或者this()都是调用构造函数，构造函数用于初始化，所以初始化的动作要先完成。
>
> **继承的细节**
>
> > 1. **细节一**
> >
> >    什么时候使用继承呢？当类与类之间存在所属关系，才具备继承的前提。
> >
> > 2. **细节二**
> >
> >    方法覆盖时需要需要注意：
> >
> >    > 1. 子类覆盖父类时，必须要保证，子类方法的权限必须大于等于父类方法权限可以实现继承。否则，编译失败。
> >    > 2. 覆盖时，要么都静态，要么都不静态。 (静态只能覆盖静态，或者被静态覆盖)。
>
> **继承的弊端**
>
> > 打破了封装性。解决办法：<font color='#FF0033'>final关键字</font>。
>

### 多态

> 多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。
>
> 面向接口编程；