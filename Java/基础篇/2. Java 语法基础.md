[TOC]

### 一、Java概述

---

#### 发展史

1991年，在Sun公司的James Gosling等人开始开发名称为Oak的语言；

1994年将Oak语言更名为Java；

##### 1. Java的三种发展架构

JAVAEE：开发企业环境下的应用程序，主要针对web程序开发；

JAVASE：完成桌面应用程序的开发，是JAVAEE与JAVAME两者的基础；

JAVAME：开发电子消费产品与嵌入式设备，如手机中的程序；

##### 2. JDK与JRE

JDK：Java Development Kit，Java的开发和运行环境，包含Java开发工具与jre；

JRE：Java Runtime Environment，Java程序的运行环境，Java运行所需要的类库+JVM（Java虚拟机）

### 二、Java基础语法

----

#### 1. 关键字

关键字：某种语言赋予了特殊含义的单词；

保留字：还没有赋予特殊含义，但是准备日后要使用的单词；

#### 2. 标识符

其实就是程序中自定义的名词。比如：类名、变量名、函数名等。包含 0-9、a-z、$、_

**注意：**

> 不能以数字开头；
>
> 不能使用关键字；

#### 3. 常量

程序中不会变化的数据。在Java中用<font color='#FF3399'>final</font>修饰。声明方式和变量类似。

虽然常量名也可以小写，但为了便于标识，通常采用大写字母标识常量。

#### 4. 变量

其实就是内存中的一个存储空间，用于存储变量数据。

**作用：** 方便于计算，因为有些数据不确定，所以确定该数据的名词和存储空间；

**特点：** 变量空间可重复使用；

**作用域：** 作用域从变量定义的位置开始，到该变量所在的那对大括号结束；

**生命周期：** 变量从定义的位置就开始在内存中存活了，变量到达它所在的作用域的时候就在内存中消失了；

**什么时候定义变量？** 只有数据不确定的时候，就定义变量

##### 1). 数据类型

| 基础类型 | boolean | byte |   char    | short |   int   | long | float | double |
| :------: | :-----: | :--: | :-------: | :---: | :-----: | :--: | :---: | :----: |
|  字节数  |    1    |  8   |    16     |  16   |   32    |  64  |  32   |   64   |
| 引用类型 | Boolean | Byte | Character | Short | Integer | Long | Float | Double |

> **级别从低到高：** byte,char,short(这三个平级) → int → float → long → double
>
> **自动类型的转换：** 从低级别到高级别，系统自动转换；
>
> **强制类型转换：** 从高级别到低级别时需要强制转换，可能会丢失精度；

##### 2). 运算符

- ###### 算数运算符

  > +、-、*、/
  >
  > **%：** 任何整数模2不是0就是1，所以只要改变模数就可以实现开关运算
  >
  > **+：** 连接符
  >
  > ++、--

- ###### 赋值运算符

  > =、+=、-=、*=、/=、%=

- ###### 比较运算符

  > **特点：** 该运算符的特点是：运算完的结果，要么是true，要么是false

- ###### 逻辑运算符

  > &	|	^	!	&&	||
  >
  > 逻辑运算符除了 ! 外都是连接两个boolean类型的表达式。
  >
  > **&(与)：** 只有两边结果为true时结果才为true，否则就是false；
  >
  > **|(或)：** 只有两边都为false时结果为false，否则就是true；
  >
  > **^(异或)：** 两边结果一样，就为false；两边结果不一样，就为true；
  >
  > **&与&&区别：**
  >
  > > *&：* 无论左边什么结果，右边都参与运算；
  > >
  > > *&&：* 短路与，如果左边为false，那么右边不参与运算；
  > >
  >
  > **|与||区别：**
  >
  > > *|：* 两边都参与计算；
  > >
  > > *||：* 短路或，如果左边为true，那么右边不参与运算；

- ###### 位运算符

  > &	|	^	<<	>>	>>>(无符号右移)
  >

  ```java
  /* 练习一、交换x与y的值 */
  int x = 3; int y = 5; 
  // 方法一
  x = x + y;
  y = x - y;
  x = x - y;
  // 方法二
  x = x ^ y;
  y = x ^ y;
  x = x ^ y;
  
  /* 练习二、高效计算出2 * 8的值 */
  2 * 8 = 2 << 3
  ```

#### 5. 判断/循环语句

> if、switch、do while、while、for

##### 1). 什么时候使用？

> 1. 单判断固定个数的时候，可以使用 **if**，也可以使用 **switch**，但是建议使用 **switch**，效率较高；
>
>    ```java
>    switch(变量) {
>    	case 值:
>    		...
>            break;
>    	default:
>            ...
>    }
>    ```
>
> >    **工作原理：** 用小括号中的变量依次和case后面的值进行比对，和那个相同了就执行case后面的语句，如果没有相同的则执行default中的语句；
> >
> >    **细节：**
> >
> >    - break是可以省略的，如果省略了就一直执行到遇到break为止；
> >    - switch后面的变量应该是byte、char、short、int四中类型中的一种，JDK1.7以后支持string类型的；
> >    - default可以写在switch接种的任意位置，如果default放在第一行，则不管expression与case中的value是否匹配，程序都会从default开始执行，直到遇到第一个break为止；
>
> 2. 当判断数据范围，获取判断运算结果为boolean类型时，需要使用 **if**；
> 3. 当某些语句需要执行很多次时，就用循环结构；while与for的区别：如果需要定义循环的次数，建议使用for，因为for循环结束后，变量在内存中释放；

##### 2). break

> 1. 作用于switch和循环语句，用于跳出或者称为结束；
>
> 2. break单独存在时，下面不要定义其他语句，因为执行不到，编译会失败；
>
> 3. 当循环嵌套时，break值跳出当前所在循环；要跳出嵌套中外部的循环，只要给循环起名字即可，这个名字称为**标号**。
>
>    ```java
>    // 方法一：采用标号
>    flag:for(int x = 0; x < 10; x++) {
>        for(int y = 10; y < 20; y++) {
>            if (x * 2 == y) {
>                break flag;
>            }
>        }
>    }
>    // 方法二：通过内层循环控制外层循环
>    boolean flag = false;
>    for(int x = 0; x < 10 && !flag; x++) {
>        for(int y = 10; y < 20; y++) {
>            if (x * 2 == y) {
>                flag = true;
>                break;
>            }
>        }
>    }
>    ```

##### 3). continue

> 1. 只作用于循环结构，终止本次循环，继续下一次循环用的；
> 2. *作用：* 结束本次循环，继续下一次循环。该语句存在时，下面不能定义语句，执行找不到；

#### 6. 函数

> 为了提高代码的复用性，可以将其定义为一个单独的功能，该功能的体现就是Java中的函数，<u>函数就是Java体现之一</u>；
>

##### 1). Java中函数的定义格式

>
> ```java
> 修饰符 返回值类型 函数名(参数类型 参数1, 参数类型 参数2) {
> 执行语句;
> return 返回值;
> }
> ```
>
>当函数没有具体的返回值时，返回的返回值类型用 **void**关键字表示；
>
>
>如果函数的返回值类型为void时，return语句可以不写，系统会自动帮你加上；
>
>**return作用：** 结束函数、结束功能；

##### 2). 如何定义一个函数

>函数其实就是一个功能，定义函数就是实现功能，通过两个明确定来完成；
>
>1. 明确该功能的运算完的结果，其实就是在明确这个函数的返回值类型；
>
>2. 在实现该功能的过程中是否有未知内容参与了运算，其实就是在明确这个函数的参数列表(参数类型&参数个数)；

##### 3). 函数的作用

>1. 用于定义功能；
>2. 用于封装代码提高代码复用性；
>3. **注意：** 函数中只能调用函数，不能定义函数；

##### <font color='#FF3399'>4). 主函数</font>

> 1. 保证该类的独立运行；
> 2. 因为他是程序的入口；
> 3. 因为它在被JVM调用；

##### 5). 函数为什么定义名称

> 1. 为了该功能进行标注，方便调用；
> 2. 为了通过函数名就可以明确函数的功能，增加代码的可读性；
>

##### 6). 重载

>在一个类中，如果出现两个或两个以上的同名函数，只有他们的参数个数不同或者参数类型不同，即可称为<font color='#FF3399'>*函数重载*</font>；与<font color='#FF3399'>返回值类型没关系</font>；

#### 7. 数组

> 用于存储同一类型数据的容器。
>
> **好处：** 可以对该容器的数据进行编号，从0开始。数组用于封装数据，就是一个具体的实体。

##### 1). 数组格式

> 1. ```java
>   元素类型[] 变量名 = new 元素类型[元素个数]；
>   ```
> ```
> 
> ```
>
> ```
> 
> ```
>
> 2. ```java
>   元素类型[] 变量名 = {元素1, 元素2, ......};
>   元素类型[] 变量名 = new 元素类型[]{元素1, 元素2, ......};
>   ```
> ```
> 
> ```
>
> ```
> 
> ```

##### 2). 二分查找法（前提：数组中的元素必须有序）

```java
/**
 * 二分查找法
 * @param arr int[]
 * @param key 待找的值
 * @return 索引
 */
public static int halfSearch(int[] arr, int key) {
	int min = 0, max = arr.length - 1, mid = (min + max) >> 1;
	while (arr[mid] != key) {
		if (key > arr[mid]) {
			min = mid + 1;
		} else if (key < arr[mid]) {
			max = mid - 1;
		}
		if (max < min) {
			return -1;
		}
		mid = (min + max) >> 1;
	}
	return mid;
}
```

#### 8.Java内存模型

> Java内存模型即 Java Memory Model，简称JMM。JMM定义了Java虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM隶属于JVM。

![JVM内存模型](https://github.com/song-qingwei/Java/blob/master/%E6%88%AA%E5%9B%BE/%E5%9F%BA%E7%A1%80%E7%AF%87/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png?raw=true)

> Java虚拟机在运行程序时会把其自动管理的内存划分为以上几个区域，每个区域都有的用途以及创建销毁的时机，其中蓝色部分代表的是所有线程共享的数据区域，而绿色部分代表的是每个线程的私有数据区域。
>
> - <font color='#FF3399'>**方法区（Method Area）**</font>
>
>   方法区属于线程共享的区域，又称Non-Heap（非堆），主要用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据；根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfmemoryError 异常。值得注意的是在方法区中存在一个运行时常量池（Runtime Constant Pool）的区域，它主要用于存放编译器生成的各种字面量和符号引用，这些内容将在类加载后存放到运行时常量池中，以便后续使用。
>
> - <font color='#FF3399'>**JVM堆（Java Heap）**</font>
>
>   Java堆也属于线程共享的区域，它在虚拟机启动时创建，是Java虚拟机所管理的内存中最大的一块，主要用于存放对象实例，几乎所有的对象实例都在这里分配内存，注意Java堆内存是垃圾收集器管理的主要区域，因此很多时候也被称为GC堆，如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfmemoryError 异常。
>
>   主要用于存放数组和对象，也就是实体
>
>   > 1. 每个实体都有内存首选地址；
>   > 2. 堆中的变量都有默认初始化值。因为数据类型不同，值也不一样；
>   > 3. 垃圾回收机制。
>
> - <font color='#FF3399'>**程序计数器（Program Counter Register）**</font>
>
>   属于线程私有的数据区域，是一小块内存空间，主导代表当前线程所执行的字节码行号指示器。字节码解释器工作时，通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理，线程恢复等基础功能都需要依赖这个计数器来完成。
>
> - <font color='#FF3399'>**虚拟机栈（Java Virtual Machine Stacks）**</font>
>
>   属于线程私有的数据区域，与线程同时创建，总数与线程关联，代表Java方法执行的内存模型。每个方法执行时都会创建一栈桢来存储方法的变量表、操作数栈、动态链接方法、返回值、返回地址等信息。每个方法从调用到结束就相对于一个栈桢在虚拟机栈中的入栈与出栈过程。
>
>   存储的都是局部变量（函数中定义的变量，函数上的参数，语句中的变量）。
>
>   只要数据运算完成所在的区域结束，该数据就会被释放。
>
> - <font color='#FF3399'>**本地方法栈（Native Method Stacks）**</font>
>
>   属于线程私有的数据区域，这部分主要与虚拟机用到的 Native 方法相关，一般情况下，我们无需关心此区域。



