#### MySQL 索引机制[B+tree]

---

##### 一、什么是索引

索引是为了加速对表中数据行的检索而创建的一种分散存储的数据结构。

##### 二、为什么要使用索引

1. 索引能极大的减少存储引擎需要扫描的数据量；
2. 索引可以把随机IO变为有序IO；
3. 索引可以帮助我们在进行分组、排序等操作时，避免使用临时表；

##### 三、为什么使用 B+tree

[树结构模拟地址](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)

###### 1. 二叉查找树

- 若任意节点的左子树不为空，则左子树上的值均小于它的根节点的值；
- 若任意节点的右子树不为空，则右子树上的值均大于它的根节点的值；
- 没有键值相等的节点；
- 二叉树的结构和插入顺序有关，也影响着查询效率；

###### 2. 平衡二叉查找树（AVL树）

- 平衡二叉树在满足二叉树的查询条件下，还满足任何节点的两个子树的高度差最大为1；

- 如果在 AVL 树中插入或删除节点，可能导致AVL树失去平衡，它包括四种姿态：LL(左左)、RR(右右)、LR(左右)、RL(右左)；

  ![平衡二叉查找树1](F:\总结\截图\技术篇\MySQL\平衡二叉查找树1.png)

- 四种失去平衡的旋转方法：

  ![平衡二叉查找树2](F:\总结\截图\技术篇\MySQL\平衡二叉查找树2.png)
  - LL的旋转：

    - 将根节点的左孩子作为新根节点

    - 将新根节点的右孩子作为原根节点的左孩子

    - 将原根节点作为新根节点的右孩子

      ![LL](F:\总结\截图\技术篇\MySQL\LL.png)

  - RR的旋转：

    - 将根节点的右孩子作为新根节点

    - 将新根节点的左孩子作为原根节点的右孩子

    - 将原根节点作为新根节点的左孩子

      ![RR](F:\总结\截图\技术篇\MySQL\RR.png)

  - LR的旋转：

    - 围绕根节点的左孩子进行RR旋转；

    - 围绕根节点进行LL旋转；

      ![LR](F:\总结\截图\技术篇\MySQL\LR.png)

  - RL旋转：

    - 围绕根节点的右孩子进行LL旋转；

    - 围绕根节点进行RR旋转；

      ![RL](F:\总结\截图\技术篇\MySQL\RL.png)

###### 3. 多路平衡查找树（B-tree）

![多路平衡查找树](F:\总结\截图\技术篇\MySQL\多路平衡查找树.png)

- B-tree 是为磁盘等外存储设备设计的一种平衡查找树。因此先要了解磁盘的相关知识。系统从磁盘读取数据到内存中是以磁盘块为基本单位的，位于同一个磁盘块中的数据会被一块读取出来。InnoDB 存储引擎中有页的概念，页是其磁盘管理的最小单位。InnoDB 中默认每页大小为`16KB`，可通过参数`innodb_page_size`调整每页大小，可通过命令查看大小：

  ```shell
  show variables like 'innodb_page_size';
  ```

- B-tree 定义了一个二元组[key, data]，key 为记录的键值，对应表中的主键，data 为一行记录中除主键以外的数据。以下为3阶的 B-tree：

  ![三阶多路平衡查找树](F:\总结\截图\技术篇\MySQL\三阶多路平衡查找树.png)

###### 4. 加强版多路平衡查找树（B+tree）

![加强版多路平衡查找树](F:\总结\截图\技术篇\MySQL\加强版多路平衡查找树.png)

B+tree相对于B-tree有几点不同：

- 非叶子节点只存储键值信息；
- 所有叶子节点之间都有一个链指针；
- 数据记录都存放在叶子节点中；

数据库中的B+树索引可以分为聚集索引和辅助索引。聚集索引的B+树的叶子节点存放的是整张表的行记录数据；辅助索引只存储相应数据的聚集索引键，即主键，当通过辅助索引来查询数据库时，InnoDB存储引擎会遍历辅助索引找到主键，然后通过主键在聚集索引中找到完整的行记录数据。

##### 四、B+tree 相对于 B-tree 比较

1. 由于每一页的存储空间是有限的，所以data数据较大时，将会导致每页能存储的key的数量很小，当存储量很大时，同时又会导致B-tree的深度较大，增大查询时的磁盘I/O次数，从而影响效率。而在B-tree中，非叶子节点上只存储key值信息，这样可以大大加大每个节点存储key的数量，降低B+tree的高度。
2. B+tree节点关键字搜索采用了闭合区间
3. B+tree节点是顺序排列的，并且相邻节点具有顺序引用的关系

##### 五、为什么要选用B+tree？

1. B+tree是B-tree的变种，它拥有B-树的优势；
2. B+树扫库、表能力更强；
3. B+树磁盘读写能力更强；
4. B+树排序能力更强；
5. B+树查询效率更加稳定；

##### 六、MySQL 索引体现形式

###### Myisam

![Myisam](F:\总结\截图\技术篇\MySQL\Myisam.png)

###### InnoDB

![InnoDB](F:\总结\截图\技术篇\MySQL\InnoDB.png)

##### 七、索引机制

1. 列的离散性：列的离散性越好，选择性就越好；
2. 最左匹配原则：在索引中关键字对比一定是从左往右依次进行，且不可跳过；
3. 联合索引列选择原则：
   - 最常用的列优先【最左匹配原则】
   - 选择离散度高的列优先【离散度高原则】
   - 宽度小的列优先【最少空间原则】
4. 覆盖索引：如果查询列可通过索引节点中的关键字直接返回，则称该索引为覆盖索引。覆盖索引可减少数据库IO，将随机IO比变为顺序IO，提高查询性能。

##### 八、使用索引总结

1. 索引列的长度能少则少；
2. 索引一定不是越多越好、越全越好，一定是建合适的；
3. 匹配列前缀可用到索引，如：`like 999%`，`like %999%`、`like %999`用不到索引；
4. `where`条件中，`not in`和`<>`操作无法用到索引；
5. 匹配范围值，`order by`也可以用到索引；
6. 多用制定列查询，只返回自己想要的数据，少用`select *`；
7. 联合索引中如果不是按照索引最左列开始查找，无法使用索引；
8. 联合索引中，精确匹配最左前列并范围匹配另一列可以用到索引；
9. 联合索引中，如果查询中有某一列的范围查询，则其右面的列无法使用到索引；
10. 全值匹配我最爱,最左前缀要遵守;
11. 带头大哥不能死,中间兄弟不能断;
12. 索引列上少计算,范围之后全失效;
13. LIKE百分写最右,覆盖索引不写星;
14. 不等空值还有or,索引失效要少用;

