### JVM运行时数据区

--------------

在JVM基础中提到过，JVM是一个特殊的进程，我们执行的java程序，都运行在一个java进程中，这个进程的作用就是加载class文件，并且执行class中的代码。既然虚拟机作为一个虚拟的计算机，来执行我们的程序，那么在执行过程中，必然要有地方存放我们的代码（class文件）；在执行的过程中，总会创建很多对象，必须要有地方存放这些对象；在执行过程中，还需要保存一些执行的状态，比如：将要执行那个方法，当前方法执行完成之后，要返回到那个方法等信息，所以，必须有个地方来保持执行的状态。上面描述中，“地方”指的就是内存区域，程序运行起来后，就是一个动态的过程，必须合理的规划内存区域，来存放各种数据。

![JVM运行时数据区](F:\总结\截图\技术篇\JVM\JVM运行时数据区.jpg)

#### 1. 程序计数器

是一块较小的内存空间，它可以看做是 **当前线程所执行的字节码的行号指示器** 。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令、分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

由于Java虚拟机的多线程是通过线程 *轮流切换* 并分配处理器执行时间的方式来实现的。在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各个线程之间计数器互不影响，独立存储。

如果线程正在执行的是一个Java方法，那这个计数器记录的是正在执行的字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（undefined）。

此内存区域是唯一一个在Java虚拟机规范中没有规定任何`OutOfMemoryError`情况的区域。

*程序计数器是线程私有的* ，它的生命周期与线程相同（随线程而生，随线程而灭）。

#### 2. Java虚拟机栈

虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的同时都会创建一个 *栈帧（Stack Frame）* 用于存储  **局部变量表、操作数栈、动态链接、方法出口等信息** 。每一个方法从被调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

在Java虚拟机规范中，对这个区域规定了两种异常情况：

1. 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出`StackOverflowError`异常；
2. 如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可以扩展），如果扩展时无法申请到足够的内存，就会抛出`OutOfMemoryError`异常。

与程序寄存器一样，*Java虚拟机栈也是线程私有的* ，它的生命周期与线程相同。

![虚拟机栈-栈桢](F:\总结\截图\技术篇\JVM\虚拟机栈-栈桢.jpg)

```java
// 通过反编译查看class存储形式
// -c 输出分解后的代码，例如，类中每一个方法内，包含java字节码的指令
// -v 输出栈大小，方法参数的个数
javap -v -c HelloWorld.class > p.txt
```

反编译后可以通过对比java字节码指令集查看每一步命令所做的事情。[java 字节码 指令集](https://blog.csdn.net/web_code/article/details/12164733)

![虚拟机栈](F:\总结\截图\技术篇\JVM\虚拟机栈.png)

**特点：**

1. Java虚拟机栈是线程私有的,生命周期与线程一致
2. 局部变量表所需的内存空间在编译期间确定,并完成分配
3. 在方法运行期间不会改变局部变量表的大小
4. 如果请求的栈深度大于虚拟机允许的深度,抛出`StackOverflowError`
5. 虚拟机栈扩展时无法申请足够的内存,抛出`OutOfMemoryError`

#### 3. 本地方法栈

本地方法栈的作用与虚拟机栈作用是非常类似，该区用来存储本地方法的局部变量表，本地方法的操作数栈等等信息。区别在于虚拟机栈执行的是java方法，本地方法栈执行的是native方法(c/c++方法)。

**特点：**

1. 线程私有，生命周期与线程一致
2. 调用的是 c/c++方法(一般用于底层交互,或者性能优化)
3. 可抛出`StackOverflowError`和`OutOfMemoryError`

#### 4. Java 堆

对大多数应用来说，Java堆（Heap）是Java虚拟机所管理的内存中最大的一块，Java堆是被 *所有线程共享* 的一块内存区域，在虚拟机启动时创建。该内存区域唯一的目的就是 **存放对象实例**，**Java对象实例以及数组都在堆上分配** 随着`JIT`编译器发展等技术成熟，所有对象分配在堆上也渐渐不是那么“绝对”了）。

*Java堆是垃圾收集器管理的主要区域*，因此Java堆也常被称为“ *GC堆* ”，由于现在收集器基于 *分代收集算法*，Java堆还可以细分为：*新生代和老年代*。默认情况下,新生代和老年代的比例是 1:2。

根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样（或者说，像链表一样虽然内存上不一定连续，但逻辑上是连续）。如果在堆中没有内存完成实例分配，而且堆也没办法再扩展时，将会抛出`OutOfMemoryError`异常。

#### 5. 方法区

方法区与Java堆一样，是各个线程共享的内存区域，用于 **存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据**。其中类相关的信息,如类名,访问修饰符,常量池,字段描述,方法描述等。Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可拓展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就成为了永久代。该区域的内存回收目标主要是针对 *常量池的回收和对类型的卸载*。

Java虚拟机规范规定，当方法区无法满足内存分配需求时，讲抛出`OutOfMemoryError`异常。

**注释：** 类的对象和实例对象存放在 java堆中, 类的元数据存放在方法区中。

##### 不同的JDK版本，方法区数据的变化

JDK 1.6以及之前,方法区的实现为 `永久代(Permanent Gen)`的方式,目的是为了垃圾收集器能像管理java堆一样管理这部分内存。垃圾回收目标是针对常量池的回收和对类型的卸载。

JDK 1.7中，存储在永久代的部分数据就已经转移到Java Heap或者Native Heap。但永久代仍存在于JDK 1.7中，并没有完全移除，如符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了Java heap；类的静态变量(class statics)存放于定义类型的class对象中，存放在Java heap中。

JDK 1.8中, 完全移除了永久代,取而代之的实现方式成为`元空间(Metaspace)`，将类元数据放到本地内存中，将字符常量池和静态变量放到Java堆里。虚拟机会为类的元数据明确分配和释放本地内存。

> 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间的最大区别在于：元空间并不在虚拟机中，而是使用本地内存。

> Native memory：本地内存，也称为C-Heap，是供JVM自身进程使用的。当Java Heap空间不足时会触发GC，但Native memory空间不够却不会触发GC。即GC不管理元空间(Metaspace)的内存。

##### 为什么移除永久代

1. 字符串存在永久代中，容易出现性能问题和内存溢出。
2. 永久代大小不容易确定，PermSize指定太小容易造成永久代OOM
3. 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。
4. Oracle 可能会将HotSpot 与 JRockit 合二为一。

#### 6. 运行时常量池

**运行时常量池是方法区的一部分**，Class文件中除了有关类的版本、字段、方法、接口等描述信息外，还有一项 **信息是常量池**，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

运行时常量池相对于Class文件常量池的另一个重要特征是具备动态性，Java语言并非不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量池放入池中。

