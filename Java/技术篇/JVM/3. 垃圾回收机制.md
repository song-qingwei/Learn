### Java垃圾回收机制

----------------

#### 一、意义

垃圾回收可以有效的防止内存泄漏，有效的使用空闲的内存。

*内存泄漏* 是指该内存空间使用完毕后未回收，在不涉及复杂数据结构的情况下，Java的内存泄漏变现为一个内存对象的生命周期超过了程序需要它的时间，我们有时也称之为“对象游离”。

#### 二、哪些内存需要回收？

对象是否可以被回收的两种经典算法：*引用计数法* 和 *可达性分析算法*。

#### 三、什么时候回收？

堆的新生代、老年代、永久代的垃圾回收时机，MinorGC 和 FullGC

#### 四、如何回收？

三种经典垃圾回收算法(标记清除算法、复制算法、标记整理算法)及分代收集算法 和 七种垃圾收集器

#### 五、如何确定一个对象是否可以被回收？

##### 1. 引用计数算法

<font color="#FF0099">引用计数算法是通过判断对象的引用数量来决定对象是否可以被回收。</font>

是垃圾收集器中的早期策略。在这种方法中，堆中的每个对象实例都有一个引用计数器。当一个对象被创建时，且将该对象实例分配给一个引用变量，该对象实例的引用计数设置为 1。当任何其它变量被赋值为这个对象的引用时，对象实例的引用计数加 1，但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数减 1。特别地，当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器均减 1。**任何引用计数为0的对象实例可以被当作垃圾收集**。

引用计数收集器可以很快的执行，并且交织在程序运行中，对程序需要不被长时间打断的实时环境比较有利，但其很难解决对象之间相互循环引用的问题。如下面的程序和示意图所示，对象objA和objB之间的引用计数永远不可能为 0，那么这两个对象就永远不能被回收。

![引用计数算法-对象之间相互引用](F:\总结\截图\技术篇\JVM\引用计数算法-对象之间相互引用.png)

```java
public class ReferenceCountingGC {
    public Object instance = null;
    public void testGc() {
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();
        objA.instance = objB;
        objB.instance = objA;
        System.GC();
        objA = null;
        objB = null;
    }
```

上述代码最后面两句将objA和objB赋值为null，也就是说objA和objB指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数器都不为 0，那么垃圾收集器就永远不会回收它们。

##### 2. 可达性分析算法

<font color="#FF0099">可达性分析算法是通过判断对象的引用链是否可达来决定对象是否可以被回收。</font>

可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，通过一系列的名为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）。当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的，如下图所示。在Java中，可作为 GC Root 的对象包括以下几种：

1. 虚拟机栈(栈帧中的局部变量表)中引用的对象；
2. 方法区中类静态属性引用的对象；
3. 方法区中常量引用的对象；
4. 本地方法栈中Native方法引用的对象；

![可达性分析算法示意图](F:\总结\截图\技术篇\JVM\可达性分析算法示意图.jpg)

#### 六、垃圾收集算法

##### 1. 标记-清除算法

标记-清除算法可分为标记和清除两个阶段。该算法首先通过从根集合进行扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象进行回收。如下图所示：

![标记-清除算法](F:\总结\截图\技术篇\JVM\标记-清除算法.jpg)

**缺点：**

1. 效率问题：标记和清除两个过程的效率都不高；
2. 空间问题：标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，因此标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

![标记-清除算法](F:\总结\截图\技术篇\JVM\标记-清除算法.png)

##### 2. 复制算法

复制算法是将可用的内存按容量划分为大小相等的两份，每次只使用其中的一块。当这一块的内存用完后，就将还存活的对象复制到另一块上，然后再把已使用过的内存空间一次清理掉。

这种算法适用于对象村汇率低的场景，比如新生代。这样使得内次都对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。

![复制算法](F:\总结\截图\技术篇\JVM\复制算法.png)

事实上，现在的商用虚拟机都采用这种算法来回收新生代。因为研究发现，新生代中的对象每次回收都基本只有10%左右的对象存活，所以需要复制的对象很少，效率高。

新生代内存分为较大的Eden空间和两块较小的Survivor空间，每次只是用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活的对象一次复制到另一块Survivor空间上，最后清理掉刚才用过的Eden和Survivor空间。HotSpot虚拟机默认Eden和Survivor的比例为8:1:1，也就是每次新生代中可用的内存空间为整个新生代容量为90%，只有10%的内存会被浪费。

![heap](F:\总结\截图\技术篇\JVM\heap.bmp)

复制收集算法在对象存活率较高时就要进行较多的复制，效率就会变低。更关键的是，如果不想浪费50%空间，就需要额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。

##### 3. 标记-整理算法

标记-整理算法的标记过程类似标记清除算法，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存，类似于磁盘整理的过程，该垃圾回收算法适用于对象存活率较高的场景（老年代）。其原理图如下：

![标记-整理算法](F:\总结\截图\技术篇\JVM\标记-整理算法.jpg)

标记整理算法与标记清除算法最显著的区别是：标记清除算法不进行对象的移动，并且仅对不存活的对象进行处理；而标记整理算法会将所有的存活对象移动到一端，并对不存活对象进行处理，因此其不会产生内存碎片。标记整理算法的作用示意图如下：

![标记整理算法示意图](F:\总结\截图\技术篇\JVM\标记整理算法示意图.png)

##### 4. 分代收集算法

对于一个大型的系统，当创建的对象和方法变量比较多时，堆内存中的对象也会比较多，如果逐一分析对象是否该回收，那么势必造成效率低下。分代收集算法是基于这样一个事实：<font color="#0099FF">不同的对象的生命周期(存活情况)是不一样的，而不同生命周期的对象位于堆中不同的区域，因此对堆内存不同区域采用不同的策略进行回收可以提高 JVM 的执行效率。</font>

当代商用虚拟机使用的都是分代收集算法：新生代对象存活率低，就采用复制算法；老年代存活率高，就用标记清除算法或者标记整理算法。Java堆内存一般可以分为新生代、老年代和永久代三个模块(Java 1.8以前)，如下图所示：

![分代收集算法](F:\总结\截图\技术篇\JVM\分代收集算法.jpg)

###### 1). 新生代（Young Generation）

新生代的目标是尽可能快速的收集掉哪些生命周期短的对象，一般情况下，一般情况下，所有新生成的对象首先都放在新生代的。在进行垃圾回收时，先将Eden区存活的对象复制到Survivor0区，然后清空Eden区，当这个Survivor0区也满了，则将Eden和Survivor0区存活的对象复制到Survivor1区，然后清空Eden和Survivor0区，此时Survivor0区是空的，然后交换Survivor0区和Survivor1区的角色（即下次垃圾回收时会扫描Eden区和Survivor1区），即保持Survivor0区为空，如此往复。特别地，当Survivor1区也不足以存放Eden区和Survivor0区的存活对象时，就将存活对象直接存放到老年代。

##### 1. 引用计数算法

##### 2. 标记-清除算法

##### 3. 标记-整理算法